/**
 * Extracteur sp√©cialis√© pour TrendTrack
 * Extrait les donn√©es des boutiques tendances avec pagination
 */

import { BaseExtractor } from './base-extractor.js';
// import { MarketTrafficExtractor } from './market-traffic-extractor.js';
// import { MarketTrafficPythonBridge } from './market-traffic-python-bridge.js';
// import { AdditionalMetricsPythonBridge } from './additional-metrics-python-bridge.js';

export class TrendTrackExtractor extends BaseExtractor {
  constructor(page, errorHandler) {
    super(page, errorHandler);
    
    // Initialiser l'extracteur de trafic par pays (JavaScript)
    // this.marketTrafficExtractor = new MarketTrafficExtractor(page);
    
    // Initialiser le pont Python pour les nouvelles fonctionnalit√©s
    // this.marketTrafficPythonBridge = new MarketTrafficPythonBridge();
    // this.additionalMetricsBridge = new AdditionalMetricsPythonBridge();
    
    // S√©lecteurs sp√©cifiques √† TrendTrack bas√©s sur l'analyse HTML
    this.selectors = {
      // Informations de la boutique
      shopName: {
        selector: 'td p.text-sm.font-semibold',
        multiple: false
      },
      shopUrl: {
        selector: 'td a[href*="http"]',
        attribute: 'href',
        multiple: false
      },
      shopDomain: {
        selector: 'td a[href*="http"]',
        multiple: false
      },
      
      // Cat√©gorie
      category: {
        selector: 'td div.h-full.w-full.flex.items-center.justify-center.text-center.flex-col.font-semibold div',
        multiple: false
      },
      
      // Visites mensuelles
      monthlyVisits: {
        selector: 'td p.font-bold',
        multiple: false
      },
      
      // Revenus mensuels
      monthlyRevenue: {
        selector: 'td div.h-full.w-full.flex.flex-col.items-center.justify-center p.font-bold',
        multiple: false
      },
      
      // Nombre d'ads live
      liveAds: {
        selector: 'td div.flex.items-center.justify-center.font-semibold p',
        multiple: false
      },
      

    };
    
    // S√©lecteurs pour la pagination
    this.paginationSelectors = {
      currentPage: {
        selector: 'input[aria-label="Go to page"]',
        attribute: 'value',
        multiple: false
      },
      totalPages: {
        selector: 'span.text-sm.text-muted-foreground',
        multiple: false
      },
      nextButton: {
        selector: 'a[aria-label="Go to next page"]',
        multiple: false
      },
      previousButton: {
        selector: 'a[aria-label="Go to previous page"]',
        multiple: false
      },
      pageNumbers: {
        selector: 'li a[class*="h-10 w-10"]',
        multiple: true
      }
    };
  }

  /**
   * Se connecte √† TrendTrack
   * @param {string} email - Email de connexion
   * @param {string} password - Mot de passe
   * @returns {Promise<boolean>} - Succ√®s de la connexion
   */
  async login(email, password) {
    console.log('üîë Connexion √† TrendTrack...');
    
    try {
      // Navigation vers la page de connexion
      await this.page.goto('https://app.trendtrack.io/en/login', {
        waitUntil: 'domcontentloaded',
        timeout: 60000
      });
      
      // Attendre que le formulaire soit charg√©
      await this.page.waitForSelector('input[type="email"][name="email"]', { timeout: 60000 });
      
      // Attendre 3 secondes comme dans le test visuel
      await this.page.waitForTimeout(3000);
      
      // Remplir le formulaire
      await this.page.fill('input[type="email"][name="email"]', email);
      await this.page.fill('input[type="password"][name="password"]', password);
      
      // Attendre 2 secondes comme dans le test visuel
      await this.page.waitForTimeout(2000);
      
      // Cliquer sur le bouton de connexion
      await this.page.click('button[type="submit"]');
      
      // Attendre la redirection comme dans le test visuel
      await this.page.waitForTimeout(5000);
      
      // V√©rifier que la connexion a r√©ussi en cherchant un √©l√©ment de la page d'accueil
      try {
        await this.page.waitForSelector('a[href*="trending-shops"]', { timeout: 60000 });
        console.log('‚úÖ Connexion r√©ussie - Page d\'accueil d√©tect√©e');
        return true;
      } catch (error) {
        console.log('‚ö†Ô∏è Connexion possiblement √©chou√©e - V√©rification de la page...');
        
        // V√©rifier l'URL actuelle
        const currentUrl = this.page.url();
        console.log(`üîç URL actuelle: ${currentUrl}`);
        
        // Si on est toujours sur la page de login, la connexion a √©chou√©
        if (currentUrl.includes('/login')) {
          console.log('‚ùå Connexion √©chou√©e - Reste sur la page de login');
          return false;
        }
        
        // Si on a √©t√© redirig√© ailleurs, consid√©rer comme r√©ussi
        console.log('‚úÖ Connexion r√©ussie - Redirection d√©tect√©e');
        return true;
      }
      
    } catch (error) {
      console.error('‚ùå Erreur de connexion:', error.message);
      return false;
    }
  }

  /**
   * Navigue vers la page des boutiques tendances
   * @param {number} [page=1] - Num√©ro de page √† charger
   * @returns {Promise<boolean>} - Succ√®s de la navigation
   */
  async navigateToTrendingShops(page = 1) {
    console.log(`üìä Navigation vers les boutiques tendances (page ${page})...`);
    try {
      // V√©rifier qu'on est bien connect√© et sur la page d'accueil
      const currentUrl = this.page.url();
      console.log(`üîç URL actuelle: ${currentUrl}`);
      
      if (currentUrl.includes('/login')) {
        console.log('‚ùå Pas connect√© - Redirection vers login d√©tect√©e');
        return false;
      }
      
      // Si on n'est pas sur la page d'accueil, y aller d'abord
      if (!currentUrl.includes('workspace') && !currentUrl.includes('trending-shops')) {
        console.log('üîÑ Navigation vers la page d\'accueil...');
        await this.page.goto('https://app.trendtrack.io/en/workspace/w-al-yakoobs-workspace-x0Qg9st', {
          waitUntil: 'domcontentloaded',
          timeout: 60000
        });
        await this.page.waitForTimeout(2000);
      }
      
      // URL compl√®te avec tous les param√®tres
      let url = 'https://app.trendtrack.io/en/workspace/w-al-yakoobs-workspace-x0Qg9st/trending-shops?include=true&tab=websites&minTraffic=500000&languages=en&currencies=USD&creationCountry=US&orderBy=liveAds';
      
      // Ajouter le param√®tre de page si n√©cessaire
      if (page > 1) {
        url += `&page=${page}`;
      }
      
      console.log(`üåê URL compl√®te de navigation: ${url}`);
      
      // Navigation en maintenant la session
      console.log(`üîÑ Chargement de la page...`);
      await this.page.goto(url, {
        waitUntil: 'domcontentloaded',
        timeout: 60000
      });
      
      // Attendre un peu pour que la page se charge compl√®tement
      await this.page.waitForTimeout(3000);
      
      // V√©rifier qu'on n'a pas √©t√© redirig√© vers login
      const finalUrl = this.page.url();
      console.log(`üîç URL finale: ${finalUrl}`);
      
      if (finalUrl.includes('/login')) {
        console.log('‚ùå Redirection vers login d√©tect√©e - Session perdue');
        return false;
      }
      
      console.log(`üîç Recherche du tableau...`);
      // Attendre que le tableau soit charg√©
      await this.page.waitForSelector('table', { timeout: 15000 });
      
      // V√©rifier que la page contient bien des donn√©es
      console.log(`üìä Comptage des lignes...`);
      const tableRows = await this.page.locator('table tbody tr').count();
      console.log(`üìä Nombre de lignes trouv√©es: ${tableRows}`);
      
      if (tableRows === 0) {
        console.log('‚ö†Ô∏è Aucune donn√©e trouv√©e sur la page');
        // V√©rifier si on est sur la bonne page
        const currentUrl = this.page.url();
        console.log(`üîç URL actuelle: ${currentUrl}`);
        return false;
      }
      
      console.log('‚úÖ Navigation vers les boutiques tendances r√©ussie');
      return true;
    } catch (error) {
      console.error(`‚ùå Erreur navigation page ${page}:`, error.message);
      console.error(`üîç Stack trace:`, error.stack);
      return false;
    }
  }

  /**
   * Trie par Live Ads
   * @returns {Promise<boolean>} - Succ√®s du tri
   */
  async sortByLiveAds() {
    console.log('üìà Tri par Live Ads...');
    
    try {
      // Attendre que l'en-t√™te soit charg√©
      await this.page.waitForSelector('th div.flex.items-center.gap-1', { timeout: 60000 });
      
      // Trouver l'en-t√™te "Live Ads" et cliquer dessus
      const liveAdsHeader = await this.page.$('th div.flex.items-center.gap-1:has-text("Live Ads")');
      if (liveAdsHeader) {
        await liveAdsHeader.click();
        
        // Attendre que le tri soit appliqu√©
        await this.page.waitForTimeout(2000);
        
        console.log('‚úÖ Tri par Live Ads appliqu√©');
        return true;
      } else {
        console.log('‚ö†Ô∏è En-t√™te Live Ads non trouv√©');
        return false;
      }
      
    } catch (error) {
      console.error('‚ùå Erreur tri Live Ads:', error.message);
      return false;
    }
  }

  /**
   * Extrait les donn√©es d'une ligne de boutique
   * @param {Object} row - √âl√©ment de ligne
   * @param {boolean} includeMarketData - Inclure les donn√©es de trafic par pays
   * @returns {Promise<Object>} - Donn√©es de la boutique
   */
  async extractShopData(row, includeMarketData = false) {
    try {
      const shopData = {};
      
      // üÜï Extraire l'ID de la boutique avec timeout r√©duit
      let rowId = null;
      try {
        const rowHtml = await row.evaluate(el => el.outerHTML, { timeout: 10000 });
        const rowIdMatch = rowHtml.match(/<tr[^>]*id=["']([^"']+)["']/);
        rowId = rowIdMatch ? rowIdMatch[1] : null;
      } catch (error) {
        console.log(`‚ö†Ô∏è Timeout extraction ID ligne, utilisation de l'index`);
        rowId = `row_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
      }
      shopData.shopId = rowId;
      
      // Utiliser une approche plus robuste pour extraire les donn√©es
      const cells = await row.locator('td').all();
      if (cells.length < 8) {
        console.log(`‚ö†Ô∏è Ligne avec seulement ${cells.length} cellules, ignor√©e`);
        return null;
      }
      
      // Extraire les donn√©es de base avec gestion d'erreur
      try {
        const shopInfoHtml = await cells[1].innerHTML();
        const shopNameMatch = shopInfoHtml.match(/<p class=\"text-sm font-semibold\">([^<]+)<\/p>/);
        shopData.shopName = shopNameMatch ? shopNameMatch[1].trim() : '';
        const shopUrlMatch = shopInfoHtml.match(/href=["']([^"']+)["']/);
        shopData.shopUrl = shopUrlMatch ? shopUrlMatch[1] : '';
        const dateMatch = shopInfoHtml.match(/(\d{2}\/\d{2}\/\d{4})/);
        shopData.creationDate = dateMatch ? dateMatch[1] : '';
      } catch (error) {
        console.error(`‚ö†Ô∏è Erreur extraction info boutique: ${error.message}`);
        shopData.shopName = '';
        shopData.shopUrl = '';
        shopData.creationDate = '';
      }
      
      try {
        shopData.category = (await cells[3].textContent()).trim();
        shopData.monthlyVisits = (await cells[4].textContent()).trim();
        shopData.monthlyRevenue = (await cells[5].textContent()).trim();
      } catch (error) {
        console.error(`‚ö†Ô∏è Erreur extraction m√©triques de base: ${error.message}`);
        shopData.category = '';
        shopData.monthlyVisits = '';
        shopData.monthlyRevenue = '';
      }
      
      // Live Ads (cellule 7) avec gestion d'erreur am√©lior√©e
      try {
        const liveAdsDiv = await cells[7].locator('div.flex.items-center.justify-center.font-semibold');
        const liveAdsP = await liveAdsDiv.locator('p').first();
        shopData.liveAds = liveAdsP ? (await liveAdsP.textContent()).trim() : '';
      } catch (error) {
        console.error(`‚ö†Ô∏è Erreur extraction Live Ads: ${error.message}`);
        shopData.liveAds = '';
      }

      // üÜï Extraction directe du nombre de produits (colonne 2)
      try {
        const productsCell = cells[2];
        const productsP = productsCell.locator("p:has(> span:has-text(\"products\"))");
        const productsText = await productsP.textContent();
        if (productsText) {
          const match = productsText.match(/\d[\d\s.,]*/);
          shopData.totalProducts = match ? Number(match[0].replace(/[^\d]/g, "")) : null;
          console.log(`üì¶ Produits extraits pour ${shopData.shopName}: ${shopData.totalProducts}`);
        } else {
          shopData.totalProducts = null;
        }
      } catch (error) {
        console.error(`‚ö†Ô∏è Erreur extraction produits pour ${shopData.shopName}:`, error.message);
        shopData.totalProducts = null;
      }



      // Ajouter les donn√©es de trafic par pays si demand√©
      if (includeMarketData && shopData.shopUrl) {
        try {
          console.log(`üåç Extraction trafic par pays pour: ${shopData.shopName}`);
          const marketData = await this.extractMarketTrafficForShop(shopData.shopId || shopData.shopUrl);
          if (marketData) {
            Object.assign(shopData, marketData);
          }
        } catch (error) {
          console.error(`‚ö†Ô∏è Erreur extraction trafic pour ${shopData.shopName}:`, error.message);
          // Ajouter des valeurs null pour les champs market_*
          shopData.market_us = null;
          shopData.market_uk = null;
          shopData.market_de = null;
          shopData.market_ca = null;
          shopData.market_au = null;
          shopData.market_fr = null;
        }
      }

      // üÜï R√©cup√©ration des m√©triques suppl√©mentaires via Python
      if (shopData.shopUrl) {
        try {
          console.log(`üîç Extraction m√©triques suppl√©mentaires pour: ${shopData.shopName}`);
          
          // Extraire les m√©triques suppl√©mentaires (total_products, pixel_google, pixel_facebook, aov)
          const pixelData = await this.extractPixelsForShopJS(shopData.shopId);
            
            shopData.pixel_google = pixelData.pixel_google;
            shopData.pixel_facebook = pixelData.pixel_facebook;
            
            console.log(`‚úÖ M√©triques suppl√©mentaires extraites pour ${shopData.shopName}`);
          
        } catch (error) {
          console.error(`‚ö†Ô∏è Erreur extraction m√©triques suppl√©mentaires pour ${shopData.shopName}:`, error.message);
          // Ajouter des valeurs null pour les champs en cas d'erreur
          shopData.totalProducts = null;
          shopData.pixel_google = "non";
          shopData.pixel_facebook = "non";
          
        }
      }

      return shopData;
    } catch (error) {
      console.error('‚ùå Erreur extraction donn√©es boutique:', error.message);
      return null;
    }
  }

  /**
   * Extrait toutes les donn√©es du tableau
   * @param {boolean} includeMarketData - Inclure les donn√©es de trafic par pays
   * @returns {Promise<Array>} - Liste des boutiques
   */
  async extractAllShopsData(includeMarketData = false) {
    console.log('üìã Extraction de toutes les donn√©es du tableau...');
    
    try {
      // Attendre que le tableau soit charg√©
      console.log('üîç Debug: Recherche du s√©lecteur tbody tr...');
      
      // Debug: capturer le contenu de la page
      const pageContent = await this.page.content();
      console.log(`üîç Debug: Taille du contenu de la page: ${pageContent.length} caract√®res`);
      
      // Debug: v√©rifier les √©l√©ments disponibles
      const hasTable = await this.page.locator('table').count();
      const hasTbody = await this.page.locator('tbody').count();
      const hasTr = await this.page.locator('tr').count();
      console.log(`üîç Debug: √âl√©ments trouv√©s - table: ${hasTable}, tbody: ${hasTbody}, tr: ${hasTr}`);
      
      // Debug: URL actuelle
      const currentUrl = await this.page.url();
      console.log(`üîç Debug: URL actuelle: ${currentUrl}`);
      
      // Debug: titre de la page
      const pageTitle = await this.page.title();
      console.log(`üîç Debug: Titre de la page: ${pageTitle}`);
      
      await this.page.waitForSelector('tbody tr', { timeout: 60000 });
      
      // R√©cup√©rer toutes les lignes du tableau
      const rows = await this.page.locator('tbody tr').all();
      console.log(`üìä ${rows.length} lignes trouv√©es`);
      
      const shopsData = [];
      
      for (let i = 0; i < rows.length; i++) {
        console.log(`üîç Extraction ligne ${i + 1}/${rows.length}...`);
        
        const shopData = await this.extractShopData(rows[i], true); // Toujours activer l'extraction des m√©triques avanc√©es
        if (shopData) {
          shopsData.push({
            ...shopData,
            rowIndex: i + 1,
            timestamp: new Date().toISOString()
          });
        }
        
        // Pause entre les extractions (plus longue si on inclut les donn√©es de trafic)
        await this.sleep(includeMarketData ? 2000 : 100);
      }
      
      console.log(`‚úÖ ${shopsData.length} boutiques extraites`);
      return shopsData;
      
    } catch (error) {
      console.error('‚ùå Erreur extraction tableau:', error.message);
      return [];
    }
  }

  /**
   * R√©cup√®re les informations de pagination
   * @returns {Promise<Object>} - Informations de pagination
   */
  async getPaginationInfo() {
    try {
      const paginationInfo = {};
      
      // Page actuelle
      const currentPageElement = await this.page.$('input[aria-label="Go to page"]');
      if (currentPageElement) {
        paginationInfo.currentPage = parseInt(await currentPageElement.getAttribute('value')) || 1;
      }
      
      // Total des pages
      const totalPagesElement = await this.page.$('span.text-sm.text-muted-foreground');
      if (totalPagesElement) {
        const totalText = await totalPagesElement.textContent();
        const match = totalText.match(/\/\s*(\d+)/);
        if (match) {
          paginationInfo.totalPages = parseInt(match[1]);
        }
      }
      
      // Bouton suivant
      const nextButton = await this.page.$('a[aria-label="Go to next page"]');
      paginationInfo.hasNextPage = nextButton !== null;
      
      // Bouton pr√©c√©dent
      const previousButton = await this.page.$('a[aria-label="Go to previous page"]');
      paginationInfo.hasPreviousPage = previousButton !== null;
      
      console.log(`üìÑ Pagination: Page ${paginationInfo.currentPage}/${paginationInfo.totalPages}`);
      return paginationInfo;
      
    } catch (error) {
      console.error('‚ùå Erreur pagination:', error.message);
      return { currentPage: 1, totalPages: 1, hasNextPage: false, hasPreviousPage: false };
    }
  }

  /**
   * Navigue vers la page suivante
   * @returns {Promise<boolean>} - Succ√®s de la navigation
   */
  async goToNextPage() {
    try {
      const nextButton = await this.page.$('a[aria-label="Go to next page"]');
      if (nextButton) {
        await nextButton.click();
        await this.page.waitForLoadState('networkidle');
        await this.page.waitForTimeout(2000); // Attendre le chargement
        
        console.log('‚úÖ Navigation vers la page suivante');
        return true;
      } else {
        console.log('‚ö†Ô∏è Pas de page suivante');
        return false;
      }
    } catch (error) {
      console.error('‚ùå Erreur navigation page suivante:', error.message);
      return false;
    }
  }

  /**
   * Navigue vers une page sp√©cifique
   * @param {number} pageNumber - Num√©ro de page
   * @returns {Promise<boolean>} - Succ√®s de la navigation
   */
  async goToPage(pageNumber) {
    try {
      // Trouver l'input de page
      const pageInput = await this.page.$('input[aria-label="Go to page"]');
      if (pageInput) {
        // Vider et remplir l'input
        await pageInput.fill('');
        await pageInput.fill(pageNumber.toString());
        
        // Appuyer sur Entr√©e
        await pageInput.press('Enter');
        
        // Attendre le chargement
        await this.page.waitForLoadState('networkidle');
        await this.page.waitForTimeout(2000);
        
        console.log(`‚úÖ Navigation vers la page ${pageNumber}`);
        return true;
      } else {
        console.log('‚ö†Ô∏è Input de page non trouv√©');
        return false;
      }
    } catch (error) {
      console.error('‚ùå Erreur navigation page sp√©cifique:', error.message);
      return false;
    }
  }

  /**
   * Scrape plusieurs pages
   * @param {number} maxPages - Nombre maximum de pages √† scraper
   * @param {boolean} includeMarketData - Inclure les donn√©es de trafic par pays
   * @returns {Promise<Array>} - Toutes les donn√©es scrap√©es
   */
  async scrapeMultiplePages(maxPages = 30, includeMarketData = false) {
    console.log(`üìã Scraping de ${maxPages} pages...`);
    
    const allShopsData = [];
    
    // Naviguer vers la premi√®re page pour s'assurer qu'on est au bon endroit
    console.log('üîÑ Navigation vers la page 1...');
    const navSuccess = await this.navigateToTrendingShops(1);
    if (!navSuccess) {
      console.log('‚ùå √âchec navigation vers la page 1');
      return [];
    }
    
    for (let page = 1; page <= maxPages; page++) {
      console.log(`\nüìÑ Scraping page ${page}...`);
      
      // Extraire les donn√©es de la page actuelle
      const pageData = await this.extractAllShopsData(includeMarketData);
      
      // Ajouter les donn√©es avec l'information de page
      const pageDataWithPage = pageData.map(shop => ({
        ...shop,
        page: page
      }));
      
      allShopsData.push(...pageDataWithPage);
      
      console.log(`‚úÖ Page ${page}: ${pageData.length} boutiques extraites`);
      
      // V√©rifier s'il y a une page suivante
      // Naviguer vers la page suivante si ce n'est pas la derni√®re
      if (page < maxPages) {
        console.log(`üîÑ Navigation vers la page ${page + 1}...`);
        const nextPageSuccess = await this.navigateToNextPage();
        if (!nextPageSuccess) {
          console.log(`‚ùå √âchec navigation vers la page ${page + 1}`);
          break;
        }
        
        // Attendre un peu entre les pages
        await this.page.waitForTimeout(2000);
      }
    }
    
    console.log(`\n‚úÖ Scraping termin√©: ${allShopsData.length} boutiques au total`);
    return allShopsData;
  }

  /**
   * Formate les donn√©es pour CSV
   * @param {Array} shopsData - Donn√©es des boutiques
   * @returns {string} - Contenu CSV
   */
  formatToCSV(shopsData) {
    if (!shopsData || shopsData.length === 0) {
      return '';
    }
    
    // D√©finir les colonnes
    const headers = [
      'Page',
      'Shop Name',
      'Shop URL',
      'Creation Date',
      'Category',
      'Monthly Visits',
      'Monthly Revenue',
      'Live Ads',
      'Market US',
      'Market UK',
      'Market DE',
      'Market CA',
      'Market AU',
      'Market FR',
      'Timestamp'
    ];
    
    const csvRows = [headers.join(',')];
    
    for (const shop of shopsData) {
      const row = [
        shop.page || '',
        `"${(shop.shopName || '').replace(/"/g, '""')}"`,
        `"${(shop.shopUrl || '').replace(/"/g, '""')}"`,
        `"${(shop.creationDate || '').replace(/"/g, '""')}"`,
        `"${(shop.category || '').replace(/"/g, '""')}"`,
        `"${(shop.monthlyVisits || '').replace(/"/g, '""')}"`,
        `"${(shop.monthlyRevenue || '').replace(/"/g, '""')}"`,
        `"${(shop.liveAds || '').replace(/"/g, '""')}"`,
        shop.market_us || '',
        shop.market_uk || '',
        shop.market_de || '',
        shop.market_ca || '',
        shop.market_au || '',
        shop.market_fr || '',
        `"${(shop.timestamp || '').replace(/"/g, '""')}"`
      ];
      
      csvRows.push(row.join(','));
    }
    
    return csvRows.join('\n');
  }

  /**
   * Extrait les donn√©es de trafic par pays pour une boutique
   * @param {string} shopUrl - URL de la boutique
   * @param {Array} targets - Liste des pays cibles (d√©faut: ["us", "uk", "de", "ca", "au", "fr"])
   * @returns {Promise<Object>} - Donn√©es de trafic par pays
   */
  async extractMarketTrafficForShop(shopUrl, targets = ["us", "uk", "de", "ca", "au", "fr"]) {
    console.log(`üåç Extraction trafic par pays pour: ${shopUrl}`);
    
    try {
      // Utiliser le pont Python pour les nouvelles fonctionnalit√©s
      const marketData = await this.extractMarketTrafficForShopJS(shopUrl, targets);
      return marketData;
    } catch (error) {
      console.error(`‚ùå Erreur extraction trafic pour ${shopUrl}:`, error.message);
      return null;
    }
  }

  /**
   * Extrait les donn√©es de trafic par pays pour plusieurs boutiques
   * @param {Array} shopUrls - Liste des URLs de boutiques
   * @param {Array} targets - Liste des pays cibles
   * @returns {Promise<Array>} - Liste des donn√©es de trafic
   */
  async extractMarketTrafficForMultipleShops(shopUrls, targets = ["us", "uk", "de", "ca", "au", "fr"]) {
    console.log(`üåç Extraction trafic par pays pour ${shopUrls.length} boutiques...`);
    
    try {
// Extraction markets en JS pur pour plusieurs boutiques      const results = [];      for (const shopUrl of shopUrls) {        const marketData = await this.extractMarketTrafficForShopJS(shopUrl, targets);        results.push(marketData);      }      return results;
    } catch (error) {
      console.error('‚ùå Erreur extraction trafic multiple:', error.message);
      return [];
    }
  }

  /**
   * Extrait les donn√©es compl√®tes d'une boutique (donn√©es de base + trafic par pays)
   * @param {Object} shopData - Donn√©es de base de la boutique
   * @param {Array} targets - Liste des pays cibles
   * @returns {Promise<Object>} - Donn√©es compl√®tes de la boutique
   */
  async extractCompleteShopData(shopData, targets = ["us", "uk", "de", "ca", "au", "fr"]) {
    console.log(`üîç Extraction compl√®te pour: ${shopData.shopName}`);
    
    try {
      // Extraire les donn√©es de trafic par pays
      const marketData = await this.extractMarketTrafficForShop(shopData.shopUrl, targets);
      
      // Combiner les donn√©es
      const completeData = {
        ...shopData,
        ...marketData
      };
      
      console.log(`‚úÖ Donn√©es compl√®tes extraites pour: ${shopData.shopName}`);
      return completeData;
      
    } catch (error) {
      console.error(`‚ùå Erreur extraction compl√®te pour ${shopData.shopName}:`, error.message);
      
      // Retourner les donn√©es de base en cas d'erreur
      return {
        ...shopData,
        market_us: null,
        market_uk: null,
        market_de: null,
        market_ca: null,
        market_au: null,
        market_fr: null,
        error: error.message
      };
    }
  }

  /**
   * Extraction pixels en JavaScript pur
   */
  async extractPixelsForShopJS(shopId) {
    console.log(`üìä Extraction pixels (JS) pour: ${shopId}`);
    const pixelData = { pixel_google: "non", pixel_facebook: "non" };
    try {
      const detailUrl = `https://app.trendtrack.io/en/workspace/w-al-yakoobs-workspace-x0Qg9st/shop/${shopId}`;
      await this.page.goto(detailUrl, { waitUntil: 'domcontentloaded', timeout: 60000 });
      await this.page.waitForTimeout(2000);

      const facebookPixel = await this.page.locator('img[alt="facebook"][src*="meta-icon.svg"]').isVisible();
      const googlePixel = await this.page.locator('img[alt="google"][src*="google-icon.svg"]').isVisible();

      if (facebookPixel) {
        pixelData.pixel_facebook = "oui";
      }
      if (googlePixel) {
        pixelData.pixel_google = "oui";
      }
      console.log(`‚úÖ Pixels extraits pour ${shopId}: Google=${pixelData.pixel_google}, Facebook=${pixelData.pixel_facebook}`);
      return pixelData;
    } catch (error) {
      console.error(`‚ùå Erreur extraction pixels pour ${shopId}:`, error.message);
      return pixelData;
    }
  }


  async checkSession() {
    try {
      const currentUrl = this.page.url();
      if (currentUrl.includes('/login')) {
        console.log('‚ùå Session expir√©e - Redirection vers login d√©tect√©e');
        return false;
      }
      
      // V√©rifier qu'on est sur une page TrendTrack valide
      if (!currentUrl.includes('trendtrack.io')) {
        console.log('‚ùå Session invalide - Pas sur TrendTrack');
        return false;
      }
      
      return true;
    } catch (error) {
      console.log(`‚ùå Erreur v√©rification session: ${error.message}`);
      return false;
    }
  }

  async ensureAuthenticated() {
    if (!(await this.checkSession())) {
      console.log('üîÑ Session expir√©e, reconnexion n√©cessaire...');
      // Ici on pourrait impl√©menter une reconnexion automatique
      // Pour l'instant, on retourne false pour arr√™ter l'extraction
      return false;
    }
    return true;
  }

  async extractMarketTrafficForShopJS(shopId, targets = ["us", "uk", "de", "ca", "au", "fr"]) {
    console.log(`üåç Extraction trafic par pays (JS) pour: ${shopId}`);
    const extractedMarkets = { ...targets.reduce((acc, t) => ({ ...acc, [`market_${t}`]: null }), {}) };

    try {
      // V√©rifier la session avant de continuer
      if (!(await this.ensureAuthenticated())) {
        console.log('‚ùå Session non valide, arr√™t de l\'extraction trafic par pays');
        return extractedMarkets;
      }
      const detailUrl = `https://app.trendtrack.io/en/workspace/w-al-yakoobs-workspace-x0Qg9st/shop/${shopId}`;
      await this.page.goto(detailUrl, { waitUntil: 'domcontentloaded', timeout: 60000 });
      await this.page.waitForTimeout(2000);

      // Essayer plusieurs s√©lecteurs pour trouver la section "Trafic par pays"
      let sectionFound = false;
      let workingSelector = null;
      const selectors = [
        'h3:has-text("Trafic par pays")',
        'h3:has-text("Traffic by Country")',
        'h3.font-semibold.tracking-tight.text-lg:has-text("Trafic")',
        'h3.font-semibold.tracking-tight.text-lg:has-text("Traffic")'
      ];
      
      for (const selector of selectors) {
        try {
          await this.page.waitForSelector(selector, { state: "visible", timeout: 5000 });
          console.log(`‚úÖ Section trouv√©e avec le s√©lecteur: ${selector}`);
          sectionFound = true;
          workingSelector = selector;
          break;
        } catch (error) {
          console.log(`‚ö†Ô∏è S√©lecteur ${selector} non trouv√©, essai suivant...`);
        }
      }
      
      if (!sectionFound) {
        console.log('‚ö†Ô∏è Section "Trafic par pays" non trouv√©e sur cette page');
        return extractedMarkets;
      }

      // Localiser la carte contenant les donn√©es avec le s√©lecteur qui a fonctionn√©
      const card = this.page.locator(workingSelector).locator('xpath=ancestor::div[contains(@class,"bg-card")]').first();
      const rows = card.locator("div.flex.gap-2.w-full.items-center");
      const count = await rows.count();

      console.log(`üìä ${count} lignes de pays trouv√©es`);

      const observedMarkets = {};

      for (let i = 0; i < count; i++) {
        const row = rows.nth(i);
        
        // Code pays via alt du drapeau ou fallback sur le premier <p> gauche
        let code = await row.locator("img[alt]").first().getAttribute("alt");
        if (!code) {
          code = await row.locator("div.flex.justify-between > p").first().textContent();
        }

        code = this.canonicalizeCountryCode(code);
        if (!code) continue;

        // Valeur (le premier <p> avant le %)
        const valueText = await row.locator("div.flex.justify-between div.items-center > p").first().textContent();
        const value = this.parseTrafficValue(valueText);

        // On enregistre uniquement si une valeur num√©rique est pr√©sente
        if (value > 0) {
          observedMarkets[code] = value;
          console.log(`  üìç ${code.toUpperCase()}: ${value.toLocaleString()}`);
        }
      }

      if (Object.keys(observedMarkets).length > 0) {
        // Au moins une valeur trouv√©e: on met 0 pour les cibles manquantes
        for (const target_code of targets) {
          extractedMarkets[`market_${target_code}`] = observedMarkets[target_code] || 0;
        }
        console.log(`‚úÖ Trafic par pays extrait: ${Object.keys(observedMarkets).length} pays trouv√©s`);
      } else {
        // Aucune donn√©e trouv√©e: on ne force pas √† 0 (null pour signaler "pas de data")
        for (const target_code of targets) {
          extractedMarkets[`market_${target_code}`] = null;
        }
        console.log('‚ö†Ô∏è Aucune donn√©e de trafic par pays trouv√©e');
      }

      console.log(`‚úÖ Trafic par pays extrait pour ${shopId}:`, extractedMarkets);
      return extractedMarkets;

    } catch (error) {
      console.error(`‚ùå Erreur lors de l'extraction du trafic par pays pour ${shopId}:`, error.message);
      return extractedMarkets;
    }
  }

  canonicalizeCountryCode(codeElement) {
    if (!codeElement) return null;
    const code = codeElement.toLowerCase();
    if (code === "us" || code === "united states") return "us";
    if (code === "uk" || code === "gb" || code === "united kingdom") return "uk";
    if (code === "de" || code === "germany") return "de";
    if (code === "ca" || code === "canada") return "ca";
    if (code === "au" || code === "australia") return "au";
    if (code === "fr" || code === "france") return "fr";
    return null;
  }

  parseTrafficValue(valueText) {
    if (!valueText) return null;
    const cleanText = valueText.replace(/[^\d.]/g, '');
    const value = parseFloat(cleanText);
    return isNaN(value) ? null : value;
  }

  /**
   * Pause pour √©viter la surcharge
   * @param {number} ms - Millisecondes √† attendre
   * @returns {Promise} - Promise qui se r√©sout apr√®s la pause
   */
  /**
   * Navigue vers la page suivante en utilisant la pagination native
   * @returns {Promise<boolean>} - Succ√®s de la navigation
   */
  async navigateToNextPage() {
    console.log('üîÑ Navigation vers la page suivante...');
    
    try {
      // Attendre que le bouton "next" soit disponible
      await this.page.waitForSelector('a[aria-label="Go to next page"]', { timeout: 10000 });
      
      // V√©rifier si le bouton est d√©sactiv√© (pas de page suivante)
      const nextButton = await this.page.$('a[aria-label="Go to next page"]');
      const isDisabled = await nextButton.getAttribute('aria-disabled');
      
      if (isDisabled === 'true') {
        console.log('‚ö†Ô∏è Pas de page suivante disponible');
        return false;
      }
      
      // Cliquer sur le bouton "next"
      await nextButton.click();
      
      // Attendre le chargement
      await this.page.waitForLoadState('networkidle');
      await this.page.waitForTimeout(2000);
      
      // V√©rifier qu'on est bien sur une nouvelle page
      const tableRows = await this.page.locator('table tbody tr').count();
      if (tableRows === 0) {
        console.log('‚ö†Ô∏è Aucune donn√©e trouv√©e sur la nouvelle page');
        return false;
      }
      
      console.log('‚úÖ Navigation vers la page suivante r√©ussie');
      return true;
    } catch (error) {
      console.error('‚ùå Erreur navigation page suivante:', error.message);
      return false;
    }
  }

  sleep(ms) {
    return new Promise(resolve => setTimeout(resolve, ms));
  }
} 
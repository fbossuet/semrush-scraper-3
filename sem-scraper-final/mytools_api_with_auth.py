#!/usr/bin/env python3
"""
API MyTools avec authentification compl√®te
Reproduit exactement le processus du scraper de production
"""

import asyncio
import json
import uuid
import time
import os
from datetime import datetime, timezone, timedelta
from playwright.async_api import async_playwright
import logging

# Configuration du logging
logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')
logger = logging.getLogger(__name__)

class MyToolsAPIWithAuth:
    def __init__(self):
        # Credentials depuis les variables d'environnement (comme le scraper de production)
        self.username = os.getenv('MYTOOLSPLAN_USERNAME')
        self.password = os.getenv('MYTOOLSPLAN_PASSWORD')
        
        if not self.username or not self.password:
            raise ValueError("‚ùå MYTOOLSPLAN_USERNAME et MYTOOLSPLAN_PASSWORD doivent √™tre d√©finis dans les variables d'environnement")
        
        self.page = None
        self.browser = None
        self.context = None
        self.base_url = "https://sam.mytoolsplan.xyz"
        self.login_url = "https://app.mytoolsplan.com/login"
        self.is_authenticated = False
        
    async def init_browser(self):
        """üöÄ Initialise le navigateur (exactement comme le scraper de production)"""
        if self.browser:
            return
            
        logger.info("üöÄ Initialisation du navigateur...")
        
        # Configuration Xvfb comme le scraper de production
        import platform
        import subprocess
        
        system = platform.system().lower()
        if system == 'linux':
            display = os.environ.get('DISPLAY')
            if not display or display == '':
                logger.info("üñ•Ô∏è Linux d√©tect√© - Configuration Xvfb...")
                try:
                    result = subprocess.run(['pgrep', '-f', 'Xvfb'], capture_output=True, text=True)
                    if result.returncode != 0:
                        logger.info("üñ•Ô∏è D√©marrage de Xvfb...")
                        subprocess.Popen(['Xvfb', ':99', '-screen', '0', '1920x1080x24'])
                        os.environ['DISPLAY'] = ':99'
                    else:
                        logger.info("üñ•Ô∏è Xvfb d√©j√† en cours")
                        os.environ['DISPLAY'] = ':99'
                except FileNotFoundError:
                    logger.warning("‚ö†Ô∏è Xvfb non trouv√©, utilisation du display par d√©faut")
        
        playwright = await async_playwright().start()
        
        # Utiliser launch_persistent_context comme le scraper de production
        self.context = await playwright.chromium.launch_persistent_context(
            user_data_dir='./session-profile-api',
            headless=True,
            args=[
                '--no-sandbox',
                '--disable-brotli',
                '--disable-features=VizDisplayCompositor',
                '--disable-dev-shm-usage',
                '--disable-gpu',
                '--no-first-run',
                '--disable-extensions'
            ],
            user_agent="Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36",
            viewport={'width': 1920, 'height': 1080}
        )
        
        self.page = await self.context.new_page()
        
        # Intercepter et bloquer localStorage.clear() (comme le scraper de production)
        await self.page.add_init_script("""
            const originalClear = Storage.prototype.clear;
            const originalSetItem = Storage.prototype.setItem;
            
            // Whitelist des cl√©s importantes √† pr√©server
            const protectedKeys = [
                'auth_token', 'session_id', 'user_data', 
                'csrf_token', 'api_key', 'login_state',
                'mytoolsplan_session', 'amember_session',
                'authentication_token', 'user_session'
            ];
            
            // Sauvegarde du contenu critique
            let criticalData = {};
            
            // Override clear() - emp√™che la suppression compl√®te
            Storage.prototype.clear = function() {
                console.log('üö® localStorage.clear() intercept√© et bloqu√©');
                
                // Sauvegarde les donn√©es critiques
                protectedKeys.forEach(key => {
                    if (this.getItem(key)) {
                        criticalData[key] = this.getItem(key);
                    }
                });
                
                // Vide le localStorage
                originalClear.call(this);
                
                // Restaure les donn√©es critiques
                Object.keys(criticalData).forEach(key => {
                    this.setItem(key, criticalData[key]);
                });
            };
        """)
    
    async def authenticate(self):
        """üîê Authentification MyToolsPlan (exactement comme le scraper de production)"""
        if self.is_authenticated:
            return True
            
        logger.info("üîê Authentification MyToolsPlan...")
        
        try:
            # Navigation vers la page de login avec timeout r√©duit
            logger.info(f"üåê Navigation vers: {self.login_url}")
            await self.page.goto(self.login_url, wait_until='domcontentloaded', timeout=30000)
            await asyncio.sleep(2)  # Attendre un peu moins
            
            # Remplir les champs de login
            logger.info("üìù Remplissage des champs de login...")
            await self.page.fill('input[name="amember_login"]', self.username)
            await self.page.fill('input[name="amember_pass"]', self.password)
            
            # Soumettre le formulaire
            logger.info("üöÄ Soumission du formulaire...")
            try:
                await self.page.click('input[type="submit"][class="frm-submit"]')
            except:
                await self.page.evaluate('document.querySelector("form[name=\\"login\\"]").submit()')
            
            # Attendre la redirection avec timeout r√©duit
            await asyncio.sleep(3)
            
            # V√©rifier que nous sommes sur la page membre
            current_url = self.page.url
            logger.info(f"‚úÖ Login r√©ussi, URL actuelle: {current_url}")
            
            if "member" not in current_url.lower():
                logger.error("‚ùå Login √©chou√© - Pas sur la page membre")
                return False
            
            # Maintenant naviguer vers sam.mytoolsplan.xyz pour les requ√™tes API
            logger.info(f"üåê Navigation vers API: {self.base_url}")
            await self.page.goto(self.base_url, wait_until='domcontentloaded', timeout=20000)
            await asyncio.sleep(1)
            
            self.is_authenticated = True
            logger.info("‚úÖ Authentification compl√®te r√©ussie")
            return True
            
        except Exception as e:
            logger.error(f"‚ùå Erreur lors de l'authentification: {e}")
            return False
    
    def calculate_date_range(self, months_back=1):
        """üìÖ Calcule la plage de dates pour les param√®tres API"""
        end_date = datetime.now(timezone.utc)
        start_date = end_date - timedelta(days=months_back * 30)
        
        return {
            'startDate': start_date.strftime('%Y-%m-%d'),
            'endDate': end_date.strftime('%Y-%m-%d'),
            'dateRange': f"{start_date.strftime('%Y-%m-%d')},{end_date.strftime('%Y-%m-%d')}"
        }
    
    async def get_organic_traffic(self, domain):
        """üìä R√©cup√®re le traffic organique via API"""
        logger.info(f"üìä R√©cup√©ration traffic organique pour: {domain}")
        
        await self.init_browser()
        if not await self.authenticate():
            return None
        
        # Calculer les dates
        date_params = self.calculate_date_range(1)
        
        # Param√®tres de base
        params = {
            "dateType": "daily",
            "searchItem": domain,
            "searchType": "domain",
            "database": "us",
            "global": True,
            **date_params
        }
        
        logger.info(f"üéØ Param√®tres API: {params}")
        
        try:
            # Requ√™te API OverviewTrend
            result = await self.page.evaluate("""
                async (data) => {
                    try {
                        console.log('üöÄ Envoi requ√™te OverviewTrend...');
                        const response = await fetch('/dpa/rpc', {
                            method: 'POST',
                            headers: {
                                'Content-Type': 'application/json',
                                'X-Requested-With': 'XMLHttpRequest'
                            },
                            credentials: 'include',
                            body: JSON.stringify({
                                id: new Date().toISOString(),
                                jsonrpc: "2.0",
                                method: "organic.OverviewTrend",
                                params: {
                                    request_id: crypto.randomUUID(),
                                    args: data.params,
                                    userId: data.credentials.userId,
                                    apiKey: data.credentials.apiKey
                                }
                            })
                        });
                        
                        console.log('üìä Status:', response.status);
                        
                        if (!response.ok) {
                            const text = await response.text();
                            console.log('‚ùå Erreur HTTP:', text);
                            return { error: `HTTP ${response.status}: ${text}` };
                        }
                        
                        const result = await response.json();
                        console.log('üìä R√©ponse OverviewTrend:', result);
                        return result;
                    } catch (error) {
                        console.log('‚ùå Erreur fetch:', error);
                        return { error: error.toString() };
                    }
                }
            """, {
                'params': params,
                'credentials': {
                    'userId': 26931056,
                    'apiKey': '943cfac719badc2ca14126e08b8fe44f'
                }
            })
            
            logger.info(f"üìä R√©ponse brute: {json.dumps(result, indent=2)}")
            
            if result.get('error'):
                logger.error(f"‚ùå Erreur API: {result['error']}")
                return None
            
            # Parser les r√©sultats
            if result.get('result'):
                latest = result['result'][-1] if result['result'] else {}
                parsed_data = {
                    'domain': domain,
                    'organic_traffic': latest.get('organicTraffic', 0),
                    'paid_traffic': latest.get('adwordsTraffic', 0),
                    'organic_positions': latest.get('organicPositions', 0),
                    'paid_positions': latest.get('adwordsPositions', 0),
                    'date': latest.get('date', ''),
                    'total_data_points': len(result['result'])
                }
                logger.info(f"‚úÖ Donn√©es pars√©es: {json.dumps(parsed_data, indent=2)}")
                return parsed_data
            
            return None
            
        except Exception as e:
            logger.error(f'‚ùå Erreur get_organic_traffic: {e}')
            return None
    
    async def get_summary_metrics(self, domain):
        """üìà R√©cup√®re les m√©triques de r√©sum√© via API"""
        logger.info(f"üìà R√©cup√©ration m√©triques r√©sum√© pour: {domain}")
        
        await self.init_browser()
        if not await self.authenticate():
            return None
        
        # Calculer les dates
        date_params = self.calculate_date_range(1)
        
        # Param√®tres de base
        params = {
            "dateType": "daily",
            "searchItem": domain,
            "searchType": "domain",
            "database": "us",
            "global": True,
            **date_params
        }
        
        try:
            # Requ√™te API Summary
            result = await self.page.evaluate("""
                async (data) => {
                    try {
                        console.log('üöÄ Envoi requ√™te Summary...');
                        const response = await fetch('/dpa/rpc', {
                            method: 'POST',
                            headers: {
                                'Content-Type': 'application/json',
                                'X-Requested-With': 'XMLHttpRequest'
                            },
                            credentials: 'include',
                            body: JSON.stringify({
                                id: new Date().toISOString(),
                                jsonrpc: "2.0",
                                method: "organic.Summary",
                                params: {
                                    request_id: crypto.randomUUID(),
                                    args: data.params,
                                    userId: data.credentials.userId,
                                    apiKey: data.credentials.apiKey
                                }
                            })
                        });
                        
                        console.log('üìà Status:', response.status);
                        
                        if (!response.ok) {
                            const text = await response.text();
                            console.log('‚ùå Erreur HTTP:', text);
                            return { error: `HTTP ${response.status}: ${text}` };
                        }
                        
                        const result = await response.json();
                        console.log('üìà R√©ponse Summary:', result);
                        return result;
                    } catch (error) {
                        console.log('‚ùå Erreur fetch:', error);
                        return { error: error.toString() };
                    }
                }
            """, {
                'params': params,
                'credentials': {
                    'userId': 26931056,
                    'apiKey': '943cfac719badc2ca14126e08b8fe44f'
                }
            })
            
            logger.info(f"üìà R√©ponse Summary brute: {json.dumps(result, indent=2)}")
            
            if result.get('error'):
                logger.error(f"‚ùå Erreur Summary API: {result['error']}")
                return None
            
            return result.get('result', {})
            
        except Exception as e:
            logger.error(f'‚ùå Erreur get_summary_metrics: {e}')
            return None
    
    async def close(self):
        """üîí Ferme le navigateur"""
        if self.context:
            await self.context.close()
            logger.info("üîí Navigateur ferm√©")

# Instance globale
_global_api_instance = None

async def get_api_instance():
    """R√©cup√®re l'instance globale (r√©utilisable)"""
    global _global_api_instance
    if _global_api_instance is None:
        _global_api_instance = MyToolsAPIWithAuth()
    return _global_api_instance

async def get_organic_traffic(domain):
    """Fonction simple pour r√©cup√©rer le traffic organique"""
    api = await get_api_instance()
    return await api.get_organic_traffic(domain)

async def get_summary_metrics(domain):
    """Fonction simple pour r√©cup√©rer les m√©triques de r√©sum√©"""
    api = await get_api_instance()
    return await api.get_summary_metrics(domain)

# Test principal
async def test_api_with_auth():
    """üß™ Test principal de l'API avec authentification"""
    print("üß™ TEST API MYTOOLS AVEC AUTHENTIFICATION")
    print("=" * 50)
    
    api = MyToolsAPIWithAuth()
    
    try:
        # Test avec un domaine simple
        test_domain = "apple.com"
        
        print(f"\nüìä Test 1: Traffic organique pour {test_domain}")
        traffic_result = await api.get_organic_traffic(test_domain)
        
        if traffic_result:
            print("‚úÖ Test traffic organique r√©ussi!")
            print(f"   Donn√©es: {json.dumps(traffic_result, indent=2)}")
        else:
            print("‚ùå Test traffic organique √©chou√©!")
        
        print(f"\nüìà Test 2: M√©triques r√©sum√© pour {test_domain}")
        summary_result = await api.get_summary_metrics(test_domain)
        
        if summary_result:
            print("‚úÖ Test m√©triques r√©sum√© r√©ussi!")
            print(f"   Donn√©es: {json.dumps(summary_result, indent=2)}")
        else:
            print("‚ùå Test m√©triques r√©sum√© √©chou√©!")
        
        # Test avec un autre domaine
        test_domain2 = "nike.com"
        print(f"\nüìä Test 3: Traffic organique pour {test_domain2}")
        traffic_result2 = await api.get_organic_traffic(test_domain2)
        
        if traffic_result2:
            print("‚úÖ Test traffic organique 2 r√©ussi!")
            print(f"   Donn√©es: {json.dumps(traffic_result2, indent=2)}")
        else:
            print("‚ùå Test traffic organique 2 √©chou√©!")
        
    except Exception as e:
        print(f"‚ùå Erreur g√©n√©rale: {e}")
    
    finally:
        if api.context:
            await api.close()
        print("\nüéâ Tests termin√©s!")

if __name__ == "__main__":
    asyncio.run(test_api_with_auth())

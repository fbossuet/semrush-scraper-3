#!/usr/bin/env python3
"""
Menu interactif pour les workers parall√®les
Interface simple et compl√®te pour g√©rer les workers
"""

import asyncio
import json
import logging
import os
import sys
import time
from datetime import datetime, timezone
from pathlib import Path
from typing import Dict, List, Optional

# Configuration du logging
logger = logging.getLogger(__name__)

def setup_logging():
    """Configure le logging"""
    logger = logging.getLogger()
    logger.handlers.clear()
    
    formatter = logging.Formatter('%(asctime)s - %(levelname)s - %(message)s')
    
    console_handler = logging.StreamHandler()
    console_handler.setFormatter(formatter)
    console_handler.setLevel(logging.INFO)
    
    logger.addHandler(console_handler)
    logger.setLevel(logging.INFO)

class WorkersMenu:
    """Menu interactif pour les workers parall√®les"""
    
    def __init__(self):
        self.lock_dir = Path("locks")
        self.results_dir = Path("results")
        self.logs_dir = Path("logs")
        self.distribution_dir = Path(".")
        
    def clear_screen(self):
        """Efface l'√©cran"""
        os.system('clear' if os.name == 'posix' else 'cls')
    
    def print_banner(self):
        """Affiche la banni√®re"""
        print("=" * 70)
        print("üè≠ MENU WORKERS PARALL√àLES - TRENDTRACK")
        print("=" * 70)
        print(f"üïí {datetime.now(timezone.utc).isoformat()}")
        print("=" * 70)
    
    def print_main_menu(self):
        """Affiche le menu principal"""
        print("\nüìã MENU PRINCIPAL:")
        print("1. üöÄ Lancer les workers SEM")
        print("2. üéØ Lancer le scraper TrendTrack")
        print("3. üßπ Nettoyer les locks")
        print("4. üìÅ Voir les fichiers r√©cents")
        print("5. üîç Voir les logs")
        print("6. üìà Monitoring en temps r√©el")
        print("7. üìä Statistiques par statut")
        print("8. ‚öôÔ∏è Configuration")
        print("9. üìñ Aide")
        print("10. üëã Quitter")
        print("-" * 50)
    
    def get_user_choice(self, min_choice: int = 1, max_choice: int = 10) -> int:
        """R√©cup√®re le choix de l'utilisateur"""
        while True:
            try:
                choice = input(f"\nVotre choix ({min_choice}-{max_choice}): ").strip()
                if choice.isdigit():
                    choice = int(choice)
                    if min_choice <= choice <= max_choice:
                        return choice
                print(f"‚ùå Choix invalide, veuillez choisir entre {min_choice} et {max_choice}")
            except KeyboardInterrupt:
                print("\nüëã Au revoir!")
                return 8
    
    def get_status_choice(self) -> str:
        """R√©cup√®re le choix du statut"""
        print("\nüéØ CHOIX DU STATUT:")
        print("1. üÜï Boutiques vides (sans statut)")
        print("2. ‚ö†Ô∏è Boutiques partial (√† compl√©ter)")
        print("3. ‚è≥ Boutiques pending (en attente)")
        print("4. üåê Toutes les boutiques √©ligibles")
        print("5. üîô Retour au menu principal")
        
        choice = self.get_user_choice(1, 5)
        
        status_map = {
            1: "empty",
            2: "partial",
            3: "pending",
            4: "all"
        }
        
        if choice == 5:
            return None
        
        return status_map[choice]
    
    def get_workers_config(self) -> tuple:
        """R√©cup√®re la configuration des workers"""
        print("\n‚öôÔ∏è CONFIGURATION DES WORKERS:")
        
        # Nombre de workers
        while True:
            try:
                num_workers = input("üë∑ Nombre de workers (1-6, d√©faut: 2): ").strip()
                if not num_workers:
                    num_workers = 2
                else:
                    num_workers = int(num_workers)
                    if 1 <= num_workers <= 6:
                        break
                    print("‚ùå Nombre de workers doit √™tre entre 1 et 6")
            except ValueError:
                print("‚ùå Nombre invalide")
        
        # Max boutiques par worker
        while True:
            try:
                max_per_worker = input("üî¢ Max boutiques par worker (d√©faut: illimit√©): ").strip()
                if not max_per_worker:
                    max_per_worker = None
                else:
                    max_per_worker = int(max_per_worker)
                    if max_per_worker > 0:
                        break
                    print("‚ùå Nombre doit √™tre positif")
            except ValueError:
                print("‚ùå Nombre invalide")
        
        return num_workers, max_per_worker
    
    def show_configuration_summary(self, status: str, num_workers: int, max_per_worker: Optional[int]):
        """Affiche le r√©sum√© de la configuration"""
        status_names = {
            "empty": "boutiques vides",
            "partial": "boutiques partial",
            "pending": "boutiques pending",
            "all": "toutes les boutiques √©ligibles"
        }
        
        print("\nüìã R√âSUM√â DE LA CONFIGURATION:")
        print(f"üéØ Statut: {status_names[status]}")
        print(f"üë∑ Workers: {num_workers}")
        if max_per_worker:
            print(f"üî¢ Max par worker: {max_per_worker}")
        else:
            print("üî¢ Max par worker: illimit√©")
        print("-" * 50)
    
    def confirm_launch(self) -> bool:
        """Demande confirmation pour le lancement"""
        confirm = input("\n‚úÖ Confirmer le lancement? (o/N): ").strip().lower()
        return confirm in ["o", "oui", "y", "yes"]
    
    async def launch_workers(self, status: str, num_workers: int, max_per_worker: Optional[int]):
        """Lance les workers dans un screen"""
        try:
            import subprocess
            import time
            from datetime import datetime, timezone
            
            print(f"\nüöÄ LANCEMENT DES WORKERS DANS UN SCREEN...")
            print("=" * 50)
            
            # V√©rifier si une session existe d√©j√†
            session_name = f"workers-{status}"
            result = subprocess.run(['screen', '-ls'], capture_output=True, text=True)
            if session_name in result.stdout:
                print(f"‚ö†Ô∏è Une session '{session_name}' existe d√©j√†")
                print("Voulez-vous la tuer et en cr√©er une nouvelle ? (y/N)")
                response = input().strip().lower()
                if response in ['y', 'yes', 'oui', 'o']:
                    subprocess.run(['screen', '-S', session_name, '-X', 'quit'])
                    print("‚úÖ Ancienne session termin√©e")
                    time.sleep(2)
                else:
                    print("‚ùå Lancement annul√©")
                    input("\nAppuyez sur Entr√©e pour continuer...")
                    return
            
            # Cr√©er le dossier logs s'il n'existe pas
            os.makedirs("logs", exist_ok=True)
            
            # Nom du fichier log avec timestamp
            timestamp = datetime.now(timezone.utc).isoformat()
            log_file = f"logs/workers-{status}-{timestamp}.log"
            
            # Construire la commande
            cmd_parts = [
                "python3", "launch_workers_by_status.py", status,
                "--workers", str(num_workers)
            ]
            if max_per_worker:
                cmd_parts.extend(["--max-per-worker", str(max_per_worker)])
            
            cmd = " ".join(cmd_parts)
            
            # Lancer dans un screen
            screen_cmd = [
                'screen', '-dmS', session_name,
                '-L', '-Logfile', log_file,
                'bash', '-c', f'cd /home/ubuntu/sem-scraper-final && {cmd}'
            ]
            
            print(f"üñ•Ô∏è Session screen: {session_name}")
            print(f"üìù Log file: {log_file}")
            print(f"üîß Commande: {cmd}")
            print()
            
            # Ex√©cuter la commande screen
            result = subprocess.run(screen_cmd, capture_output=True, text=True)
            
            if result.returncode == 0:
                print("‚úÖ WORKERS LANC√âS AVEC SUCC√àS!")
                print("=" * 50)
                print("üìã Commandes utiles:")
                print(f"   screen -r {session_name}        # Attacher au scraper")
                print(f"   screen -ls                      # Voir toutes les sessions")
                print(f"   tail -f {log_file}              # Suivre les logs")
                print(f"   screen -S {session_name} -X quit # Arr√™ter le scraper")
                print()
                print("üí° Le scraper tourne maintenant en arri√®re-plan")
                print("üí° Vous pouvez fermer ce terminal sans probl√®me")
            else:
                print(f"‚ùå Erreur lors du lancement: {result.stderr}")
            
            input("\nAppuyez sur Entr√©e pour continuer...")
            
        except Exception as e:
            print(f"‚ùå Erreur lors du lancement: {e}")
            input("\nAppuyez sur Entr√©e pour continuer...")
    
    async def launch_trendtrack_scraper(self):
        """Lance le scraper TrendTrack de production"""
        try:
            import subprocess
            import time
            from datetime import datetime, timezone
            
            print(f"\nüéØ LANCEMENT DU SCRAPER TRENDTRACK...")
            print("=" * 50)
            
            # V√©rifier si une session existe d√©j√†
            session_name = "trendtrack-scraper"
            result = subprocess.run(['screen', '-ls'], capture_output=True, text=True)
            if session_name in result.stdout:
                print(f"‚ö†Ô∏è Une session '{session_name}' existe d√©j√†")
                print("Voulez-vous la tuer et en cr√©er une nouvelle ? (y/N)")
                response = input().strip().lower()
                if response in ['y', 'yes', 'oui', 'o']:
                    subprocess.run(['screen', '-S', session_name, '-X', 'quit'])
                    print("‚úÖ Ancienne session termin√©e")
                    time.sleep(2)
                else:
                    print("‚ùå Lancement annul√©")
                    input("\nAppuyez sur Entr√©e pour continuer...")
                    return
            
            # Cr√©er le dossier logs s'il n'existe pas
            os.makedirs("logs", exist_ok=True)
            
            # Nom du fichier log avec timestamp
            timestamp = datetime.now(timezone.utc).isoformat()
            log_file = f"logs/trendtrack-scraper-{timestamp}.log"
            
            # Construire la commande pour le scraper TrendTrack
            cmd = "node update-database.js"
            
            # Lancer dans un screen
            screen_cmd = [
                'screen', '-dmS', session_name,
                '-L', '-Logfile', log_file,
                'bash', '-c', f'cd /home/ubuntu/trendtrack-scraper-final && {cmd}'
            ]
            
            print(f"üñ•Ô∏è Session screen: {session_name}")
            print(f"üìù Log file: {log_file}")
            print(f"üîß Commande: {cmd}")
            print()
            
            # Ex√©cuter la commande screen
            result = subprocess.run(screen_cmd, capture_output=True, text=True)
            
            if result.returncode == 0:
                print("‚úÖ SCRAPER TRENDTRACK LANC√â AVEC SUCC√àS!")
                print("=" * 50)
                print("üìã Commandes utiles:")
                print(f"   screen -r {session_name}        # Attacher au scraper")
                print(f"   screen -ls                      # Voir toutes les sessions")
                print(f"   tail -f {log_file}              # Suivre les logs")
                print(f"   screen -S {session_name} -X quit # Arr√™ter le scraper")
                print()
                print("üí° Le scraper TrendTrack tourne maintenant en arri√®re-plan")
                print("üí° Vous pouvez fermer ce terminal sans probl√®me")
            else:
                print(f"‚ùå Erreur lors du lancement: {result.stderr}")
            
            input("\nAppuyez sur Entr√©e pour continuer...")
            
        except Exception as e:
            print(f"‚ùå Erreur lors du lancement: {e}")
            input("\nAppuyez sur Entr√©e pour continuer...")
    
    def clean_locks(self):
        """Nettoie les locks"""
        try:
            if self.lock_dir.exists():
                lock_files = list(self.lock_dir.glob("*.lock"))
                if lock_files:
                    for lock_file in lock_files:
                        lock_file.unlink()
                    print(f"‚úÖ {len(lock_files)} fichier(s) de lock supprim√©(s)")
                else:
                    print("‚ÑπÔ∏è Aucun fichier de lock trouv√©")
            else:
                print("‚ÑπÔ∏è R√©pertoire locks n'existe pas")
                
        except Exception as e:
            print(f"‚ùå Erreur lors du nettoyage: {e}")
        
        input("\nAppuyez sur Entr√©e pour continuer...")
    
    def show_recent_files(self):
        """Affiche les fichiers r√©cents"""
        try:
            print("\nüìÅ FICHIERS R√âCENTS:")
            
            # Fichiers de r√©sultats
            results_files = sorted(Path(".").glob("results_*.json"), 
                                 key=lambda f: f.stat().st_mtime, reverse=True)[:5]
            if results_files:
                print("\nüìÑ R√©sultats r√©cents:")
                for f in results_files:
                    mtime = datetime.fromtimestamp(f.stat().st_mtime)
                    print(f"  {f.name} ({mtime.strftime('%H:%M:%S')})")
            
            # Fichiers de distribution
            distribution_files = sorted(Path(".").glob("distribution_*.json"), 
                                      key=lambda f: f.stat().st_mtime, reverse=True)[:5]
            if distribution_files:
                print("\nüì¶ Distributions r√©centes:")
                for f in distribution_files:
                    mtime = datetime.fromtimestamp(f.stat().st_mtime)
                    print(f"  {f.name} ({mtime.strftime('%H:%M:%S')})")
            
        except Exception as e:
            print(f"‚ùå Erreur fichiers r√©cents: {e}")
        
        input("\nAppuyez sur Entr√©e pour continuer...")
    
    def show_logs(self):
        """Affiche les logs"""
        try:
            print("\nüîç LOGS:")
            
            # Logs dans le r√©pertoire principal
            log_files = sorted(Path(".").glob("*.log"), 
                             key=lambda f: f.stat().st_mtime, reverse=True)[:5]
            if log_files:
                print("\nüìù Logs r√©cents:")
                for f in log_files:
                    mtime = datetime.fromtimestamp(f.stat().st_mtime)
                    size = f.stat().st_size
                    print(f"  {f.name} ({mtime.strftime('%H:%M:%S')}, {size} bytes)")
            
            # Logs dans le r√©pertoire logs
            if self.logs_dir.exists():
                logs_files = sorted(self.logs_dir.glob("*.log"), 
                                  key=lambda f: f.stat().st_mtime, reverse=True)[:5]
                if logs_files:
                    print("\nüìÇ Logs dans logs/:")
                    for f in logs_files:
                        mtime = datetime.fromtimestamp(f.stat().st_mtime)
                        size = f.stat().st_size
                        print(f"  {f.name} ({mtime.strftime('%H:%M:%S')}, {size} bytes)")
            
        except Exception as e:
            print(f"‚ùå Erreur logs: {e}")
        
        input("\nAppuyez sur Entr√©e pour continuer...")
    
    def show_configuration(self):
        """Affiche la configuration"""
        try:
            print("\n‚öôÔ∏è CONFIGURATION ACTUELLE:")
            
            # V√©rifier les r√©pertoires
            dirs = ["locks", "logs", "results"]
            for dir_name in dirs:
                dir_path = Path(dir_name)
                if dir_path.exists():
                    files_count = len(list(dir_path.glob("*")))
                    print(f"üìÅ {dir_name}/: {files_count} fichiers")
                else:
                    print(f"üìÅ {dir_name}/: n'existe pas")
            
            # V√©rifier les fichiers principaux
            main_files = [
                "launch_workers_by_status.py",
                "production_scraper_parallel.py",
                "trendtrack_api_vps_adapted.py"
            ]
            
            print("\nüìÑ Fichiers principaux:")
            for file_name in main_files:
                file_path = Path(file_name)
                if file_path.exists():
                    print(f"‚úÖ {file_name}")
                else:
                    print(f"‚ùå {file_name}")
            
        except Exception as e:
            print(f"‚ùå Erreur configuration: {e}")
        
        input("\nAppuyez sur Entr√©e pour continuer...")
    
    def show_realtime_monitoring(self):
        """Affiche le monitoring en temps r√©el (comme simple_monitor.py)"""
        try:
            print("\nüìà MONITORING EN TEMPS R√âEL:")
            print("üí° Appuyez sur Ctrl+C pour quitter")
            print("-" * 50)
            
            import time
            
            while True:
                self.clear_screen()
                print("=" * 60)
                print("üè≠ MONITEUR SIMPLE WORKERS PARALL√àLES")
                print("=" * 60)
                print(f"üïí {datetime.now(timezone.utc).isoformat()}")
                print()
                
                # Statut g√©n√©ral
                status = self.load_workers_status()
                if status:
                    print("üìä STATUT G√âN√âRAL:")
                    print(f"  üë∑ Workers configur√©s: {status.get('num_workers', 0)}")
                    print(f"  üöÄ D√©marrage: {status.get('start_time', 'N/A')}")
                    print(f"  üîÑ Workers actifs: {status.get('active_processes', 0)}")
                    print()
                    
                    # Statut des workers
                    worker_status_dict = status.get('worker_status', {})
                    if worker_status_dict:
                        print("üë∑ STATUT DES WORKERS:")
                        for worker_id, worker_status in worker_status_dict.items():
                            status_icon = "üü¢" if worker_status.get('status') == 'running' else "üî¥"
                            print(f"  {status_icon} Worker {worker_id}: {worker_status.get('status', 'unknown')}")
                    else:
                        print("‚ùå Aucun worker en cours")
                        print()
                
                
                # Statut des locks
                lock_status = self.get_lock_status()
                if lock_status:
                    print("üîí STATUT DES LOCKS:")
                    for worker_id, is_locked in lock_status.items():
                        lock_icon = "üîí" if is_locked else "üîì"
                        print(f"  {lock_icon} Worker {worker_id}: {'Verrouill√©' if is_locked else 'Libre'}")
                    print()
                
                # M√©triques de performance
                performance = self.calculate_performance_metrics()
                if performance:
                    print("üìä M√âTRIQUES DE PERFORMANCE:")
                    print(f"  üè™ Boutiques trait√©es: {performance['session_shops_processed']}")
                    print(f"  ‚úÖ M√©triques trouv√©es: {performance['session_metrics_found']}")
                    print(f"  ‚ùå M√©triques non trouv√©es: {performance['session_metrics_not_found']}")
                    print(f"  üöÄ Vitesse: {performance['session_speed_per_hour']:.1f} boutiques/h")
                    print(f"  ‚è±Ô∏è Temps restant estim√©: {performance['estimated_time_remaining']}")
                    print(f"  üìä Progression: {performance['progress_percentage']:.1f}%")
                    print()
                
                # Logs r√©cents
                logs = self.get_recent_logs(3)
                if logs:
                    print("üìù LOGS R√âCENTS:")
                    for log_line in logs:
                        print(f"  {log_line.strip()}")
                    print()
                
                print("=" * 60)
                print("üí° Appuyez sur Ctrl+C pour quitter")
                print("=" * 60)
                
                time.sleep(5)  # Rafra√Æchir toutes les 5 secondes
                
        except KeyboardInterrupt:
            print("\nüëã Monitoring arr√™t√©")
        except Exception as e:
            print(f"‚ùå Erreur monitoring: {e}")
        
        input("\nAppuyez sur Entr√©e pour continuer...")
    
    def get_lock_status(self):
        """V√©rifie le statut des locks (comme le syst√®me original)"""
        lock_status = {}
        
        try:
            if self.lock_dir.exists():
                # Chercher les locks de workers (syst√®me original)
                for lock_file in self.lock_dir.glob("scraping_lock_worker_*.lock"):
                    try:
                        worker_id = int(lock_file.stem.split('_')[-1])
                        lock_status[worker_id] = True
                    except (ValueError, IndexError):
                        continue
                
                # Chercher aussi les locks globaux
                for lock_file in self.lock_dir.glob("*global*.lock"):
                    lock_status["global"] = True
                        
        except Exception as e:
            print(f"‚ùå Erreur v√©rification locks: {e}")
        
        return lock_status
    
    def get_recent_logs(self, lines: int = 5):
        """R√©cup√®re les logs r√©cents"""
        try:
            if not self.logs_dir.exists():
                return []
            
            # Chercher les fichiers de logs les plus r√©cents
            log_files = list(self.logs_dir.glob("*.log"))
            if not log_files:
                return []
            
            # Prendre le fichier le plus r√©cent
            latest_log = max(log_files, key=lambda f: f.stat().st_mtime)
            
            # Lire les derni√®res lignes
            with open(latest_log, 'r') as f:
                all_lines = f.readlines()
                return all_lines[-lines:] if len(all_lines) > lines else all_lines
                
        except Exception as e:
            print(f"‚ùå Erreur lecture logs: {e}")
            return []
    
    def load_workers_status(self):
        """Charge le statut des workers (comme le syst√®me original)"""
        try:
            # Chercher le fichier de statut original
            status_file = Path("parallel_workers_status.json")
            if not status_file.exists():
                # Si pas de fichier de statut, v√©rifier les sessions screen actives
                return self.get_screen_sessions_status()
            
            with open(status_file, 'r') as f:
                return json.load(f)
                
        except Exception as e:
            print(f"‚ùå Erreur chargement statut workers: {e}")
            return None
    
    def get_screen_sessions_status(self):
        """R√©cup√®re le statut des sessions screen (comme auto_monitor.py)"""
        try:
            import subprocess
            
            result = subprocess.run(['screen', '-ls'], capture_output=True, text=True)
            output = result.stdout
            
            # Chercher les sessions de workers
            worker_sessions = []
            for line in output.split('\n'):
                if 'workers-' in line or 'sem-scraper-worker-' in line:
                    parts = line.split()
                    if len(parts) >= 2:
                        session_name = parts[0].replace('\t', '')
                        status = "running" if '.' in parts[0] else "detached"
                        worker_sessions.append({
                            "name": session_name,
                            "status": status
                        })
            
            # Si pas de sessions screen, essayer de d√©tecter depuis les logs
            if not worker_sessions:
                # Essayer de d√©terminer le nombre de workers depuis la distribution
                distribution = self.load_distribution()
                num_workers = 0
                if distribution and 'distribution' in distribution:
                    num_workers = len(distribution['distribution'])
                
                # Analyser les logs r√©cents pour d√©tecter les workers actifs
                latest_log_file = self.get_latest_log_file()
                active_workers = set()
                if latest_log_file:
                    try:
                        with open(latest_log_file, 'r', encoding='utf-8') as f:
                            log_content = f.read()
                            import re
                            # Chercher tous les workers dans le log
                            worker_matches = re.findall(r'Worker (\d+)', log_content)
                            active_workers = set(int(w) for w in worker_matches)
                    except:
                        pass
                
                # Utiliser le nombre de workers d√©tect√©s dans les logs ou la distribution
                if active_workers:
                    detected_workers = max(active_workers) + 1
                    # Prendre le maximum entre la distribution et les workers d√©tect√©s
                    num_workers = max(num_workers, detected_workers)
                
                # Calculer les boutiques trait√©es par worker
                worker_shops_processed = {}
                if latest_log_file:
                    try:
                        with open(latest_log_file, 'r', encoding='utf-8') as f:
                            log_content = f.read()
                            import re
                            # Compter les boutiques par worker
                            for worker_id in active_workers:
                                pattern = f'Worker {worker_id}: Boutique \\d+/\\d+'
                                matches = re.findall(pattern, log_content)
                                worker_shops_processed[str(worker_id)] = len(matches)
                    except:
                        pass
                
                return {
                    "timestamp": datetime.now(timezone.utc).isoformat(),
                    "num_workers": num_workers,
                    "start_time": datetime.now(timezone.utc).isoformat(),
                    "worker_status": {
                        str(i): {
                            "status": "running" if i in active_workers else "starting",
                            "pid": "N/A",
                            "shops_processed": worker_shops_processed.get(i, 0),
                            "errors": 0
                        }
                        for i in range(num_workers)
                    },
                    "active_processes": len(active_workers) if active_workers else len(worker_sessions)
                }
            else:
                # Cas o√π il n'y a pas de workers d√©tect√©s
                return {
                    "timestamp": datetime.now(timezone.utc).isoformat(),
                    "num_workers": 0,
                    "start_time": "N/A",
                    "active_processes": 0,
                    "worker_status": {}
                }
                
        except Exception as e:
            print(f"‚ùå Erreur r√©cup√©ration sessions screen: {e}")
            return None
    
    def load_distribution(self):
        """Charge la distribution des boutiques (comme le syst√®me original)"""
        try:
            # D'abord chercher le fichier original shop_distribution.json
            original_file = Path("shop_distribution.json")
            if original_file.exists():
                with open(original_file, 'r') as f:
                    return json.load(f)
            
            # Sinon chercher les fichiers de distribution r√©cents
            distribution_files = list(Path(".").glob("distribution_*.json"))
            if not distribution_files:
                return None
            
            # Prendre le fichier le plus r√©cent
            latest_distribution = max(distribution_files, key=lambda f: f.stat().st_mtime)
            
            with open(latest_distribution, 'r') as f:
                return json.load(f)
                
        except Exception as e:
            print(f"‚ùå Erreur chargement distribution: {e}")
            return None
    
    def get_latest_log_file(self):
        """Trouve le dernier fichier de log en cours d'√©criture"""
        try:
            import os
            from pathlib import Path
            
            logs_dir = Path("/home/ubuntu/sem-scraper-final/logs")
            if not logs_dir.exists():
                return None
            
            # Trouver tous les fichiers de log d'aujourd'hui
            today = datetime.now(timezone.utc).isoformat()
            log_files = list(logs_dir.glob(f"workers_by_status_{today}_*.log"))
            
            if not log_files:
                return None
            
            # Retourner le plus r√©cent
            return str(max(log_files, key=os.path.getmtime))
            
        except Exception as e:
            print(f"‚ùå Erreur recherche log: {e}")
            return None

    def calculate_performance_metrics(self):
        """Calcule les m√©triques de performance bas√©es sur le dernier fichier de log en cours d'√©criture"""
        try:
            metrics = {
                "total_shops_processed": 0,
                "total_metrics_found": 0,
                "total_metrics_not_found": 0,
                "total_metrics": 0,
                "session_shops_processed": 0,
                "session_metrics_found": 0,
                "session_metrics_not_found": 0,
                "session_start_time": None,
                "average_speed_per_hour": 0,
                "session_speed_per_hour": 0,
                "estimated_time_remaining": "N/A",
                "progress_percentage": 0
            }
            
            # Trouver le dernier fichier de log en cours d'√©criture
            latest_log_file = self.get_latest_log_file()
            if not latest_log_file:
                return metrics
            
            # Lire le contenu du dernier fichier de log
            try:
                with open(latest_log_file, 'r', encoding='utf-8') as f:
                    log_content = f.read()
            except:
                return metrics

            # Analyser le contenu du log
            import re
            
            # 1. COMPTER LES BOUTIQUES TRAIT√âES (pattern correct)
            # Pattern pour "Worker X: Boutique Y/Z" - chaque ligne = 1 boutique trait√©e
            shop_patterns = re.findall(r'Worker \d+: Boutique \d+/\d+', log_content)
            metrics["session_shops_processed"] = len(shop_patterns)
            
            # 2. COMPTER LES M√âTRIQUES TROUV√âES ET NON TROUV√âES (comptage correct)
            # Compter tous les ‚úÖ sauf ceux des messages de worker
            all_checkmarks = log_content.count("‚úÖ")
            worker_checkmarks = log_content.count("‚úÖ Worker")
            metrics["session_metrics_found"] = all_checkmarks - worker_checkmarks
            
            # Compter tous les ‚ùå sauf ceux des messages de worker et d'erreur
            all_crosses = log_content.count("‚ùå")
            worker_crosses = log_content.count("‚ùå Worker")
            error_crosses = log_content.count("‚ùå Erreur")
            metrics["session_metrics_not_found"] = all_crosses - worker_crosses - error_crosses
            
            # Calculer les totaux (identiques aux session maintenant)
            metrics["total_shops_processed"] = metrics["session_shops_processed"]
            metrics["total_metrics_found"] = metrics["session_metrics_found"]
            metrics["total_metrics_not_found"] = metrics["session_metrics_not_found"]
            metrics["total_metrics"] = metrics["total_metrics_found"] + metrics["total_metrics_not_found"]
            
            # 3. CALCULER LA VITESSE (bas√©e sur les timestamps r√©els)
            if metrics["session_shops_processed"] > 0:
                try:
                    from datetime import datetime, timezone
                    
                    # Extraire tous les timestamps du log
                    timestamp_pattern = r'(\d{4}-\d{2}-\d{2} \d{2}:\d{2}:\d{2})'
                    timestamps = re.findall(timestamp_pattern, log_content)
                    
                    if len(timestamps) >= 2:
                        start_time = datetime.strptime(timestamps[0], '%Y-%m-%d %H:%M:%S')
                        end_time = datetime.strptime(timestamps[-1], '%Y-%m-%d %H:%M:%S')
                        
                        duration_hours = (end_time - start_time).total_seconds() / 3600
                        if duration_hours > 0.01:  # Plus de 36 secondes
                            metrics["session_speed_per_hour"] = metrics["session_shops_processed"] / duration_hours
                        else:
                            metrics["session_speed_per_hour"] = 0
                    else:
                        metrics["session_speed_per_hour"] = 0
                        
                except Exception as e:
                    metrics["session_speed_per_hour"] = 0
            
            # Vitesse moyenne = vitesse de session
            metrics["average_speed_per_hour"] = metrics["session_speed_per_hour"]
            
            # 4. CALCULER LA PROGRESSION (bas√©e sur les boutiques √©ligibles)
            distribution = self.load_distribution()
            if distribution:
                eligible_shops = distribution.get('eligible_shops', 0)
                if eligible_shops > 0:
                    metrics["progress_percentage"] = (metrics["session_shops_processed"] / eligible_shops) * 100
                    
                    # Estimation du temps restant
                    if metrics["session_speed_per_hour"] > 0:
                        remaining_shops = eligible_shops - metrics["session_shops_processed"]
                        hours_remaining = remaining_shops / metrics["session_speed_per_hour"]
                        metrics["estimated_time_remaining"] = f"{hours_remaining:.1f}h"
            
            return metrics
            
        except Exception as e:
            print(f"‚ùå Erreur calcul m√©triques: {e}")
            return None
    
    def show_shop_status_stats(self):
        """Affiche les statistiques des boutiques par statut"""
        try:
            print("\nüìä STATISTIQUES DES BOUTIQUES PAR STATUT")
            print("=" * 60)
            
            # Connexion √† la base de donn√©es
            import sqlite3
            db_path = "/home/ubuntu/trendtrack-scraper-final/data/trendtrack.db"
            
            if not os.path.exists(db_path):
                print("‚ùå Base de donn√©es non trouv√©e")
                return
            
            conn = sqlite3.connect(db_path)
            cursor = conn.cursor()
            
            # Requ√™te pour compter les boutiques par statut
            query = """
            SELECT 
                scraping_status,
                COUNT(*) as count
            FROM shops 
            WHERE scraping_status IS NOT NULL 
            GROUP BY scraping_status
            ORDER BY count DESC
            """
            
            cursor.execute(query)
            results = cursor.fetchall()
            
            if results:
                total_shops = sum(row[1] for row in results)
                print(f"üìà Total boutiques avec statut: {total_shops}")
                print()
                
                for status, count in results:
                    percentage = (count / total_shops) * 100
                    status_icon = {
                        'completed': '‚úÖ',
                        'partial': '‚ö†Ô∏è',
                        'na': 'üåê',
                        'failed': '‚ùå',
                        'empty': 'üÜï'
                    }.get(status, 'üìä')
                    
                    print(f"  {status_icon} {status.upper()}: {count} boutiques ({percentage:.1f}%)")
                
                print()
                
                # Statistiques suppl√©mentaires
                cursor.execute("SELECT COUNT(*) FROM shops WHERE scraping_status IS NULL OR scraping_status = ''")
                empty_count = cursor.fetchone()[0]
                
                cursor.execute("SELECT COUNT(*) FROM shops")
                total_all = cursor.fetchone()[0]
                
                print(f"üìä R√âSUM√â:")
                print(f"  üè™ Total boutiques: {total_all}")
                print(f"  üìä Avec statut: {total_shops}")
                print(f"  üÜï Sans statut: {empty_count}")
                print(f"  üìà Taux de traitement: {(total_shops/total_all*100):.1f}%")
                
            else:
                print("‚ùå Aucune donn√©e trouv√©e")
            
            conn.close()
            
        except Exception as e:
            print(f"‚ùå Erreur lors de la r√©cup√©ration des statistiques: {e}")
        
        input("\nAppuyez sur Entr√©e pour continuer...")

    def show_help(self):
        """Affiche l'aide"""
        print("\nüìñ AIDE - MENU WORKERS PARALL√àLES")
        print("=" * 60)
        print("üéØ OBJECTIF:")
        print("   Interface simple pour g√©rer les workers parall√®les")
        print()
        print("üìã MENU PRINCIPAL:")
        print("   1. üöÄ Lancer les workers SEM - D√©marre le scraping SEM")
        print("   2. üéØ Lancer le scraper TrendTrack - D√©marre le scraper TrendTrack")
        print("   3. üßπ Nettoyer les locks - Supprime les fichiers de lock")
        print("   4. üìÅ Fichiers r√©cents - Liste les fichiers r√©cents")
        print("   5. üîç Logs - Affiche les logs disponibles")
        print("   6. üìà Monitoring temps r√©el - Surveillance en direct")
        print("   7. üìä Statistiques par statut - Affiche les boutiques par statut")
        print("   8. ‚öôÔ∏è Configuration - V√©rifie la configuration")
        print("   9. üìñ Aide - Affiche cette aide")
        print("   10. üëã Quitter - Ferme le menu")
        print()
        print("üéØ TYPES DE SCRAPERS:")
        print("   üöÄ Workers SEM - Scraping parall√®le des m√©triques MyToolsPlan")
        print("   üéØ TrendTrack - Scraping des boutiques depuis trendtrack.io")
        print()
        print("üéØ STATUTS DISPONIBLES (Workers SEM):")
        print("   üÜï Empty   - Boutiques sans statut ou statut vide")
        print("   ‚ö†Ô∏è Partial - Boutiques avec statut 'partial'")
        print("   üåê All     - Toutes les boutiques √©ligibles")
        print()
        print("‚öôÔ∏è CONFIGURATION:")
        print("   üë∑ Workers - Nombre de workers parall√®les (1-6)")
        print("   üî¢ Max par worker - Limite le nombre de boutiques")
        print()
        print("üìÅ FICHIERS G√âN√âR√âS:")
        print("   üìÑ results_*.json - R√©sultats d√©taill√©s du scraping")
        print("   üì¶ distribution_*.json - R√©partition des boutiques")
        print("   üîí locks/*.lock - Fichiers de verrouillage")
        print("   üìù logs/*.log - Logs des workers")
        print()
        print("üí° CONSEILS:")
        print("   - Commencez par 'partial' pour tester")
        print("   - Utilisez 2-4 workers pour commencer")
        print("   - Limitez le nombre pour les tests")
        print("   - Nettoyez les locks en cas de probl√®me")
        print("   - Utilisez Ctrl+C pour arr√™ter le scraping")
        print("   - D√©lai d'authentification automatique entre workers")
        print("   - Monitoring temps r√©el pour surveiller l'avancement")
        print("=" * 60)
        
        input("\nAppuyez sur Entr√©e pour continuer...")
    
    async def run_menu(self):
        """Lance le menu principal"""
        while True:
            try:
                self.clear_screen()
                self.print_banner()
                self.print_main_menu()
                
                choice = self.get_user_choice()
                
                if choice == 1:  # Lancer les workers SEM
                    status = self.get_status_choice()
                    if status:
                        num_workers, max_per_worker = self.get_workers_config()
                        self.show_configuration_summary(status, num_workers, max_per_worker)
                        
                        if self.confirm_launch():
                            await self.launch_workers(status, num_workers, max_per_worker)
                
                elif choice == 2:  # Lancer le scraper TrendTrack
                    print("\nüéØ LANCEMENT DU SCRAPER TRENDTRACK")
                    print("=" * 50)
                    print("‚ö†Ô∏è ATTENTION: Ce scraper va traiter les boutiques TrendTrack")
                    print("üìä Il utilisera la base de donn√©es vide r√©cemment cr√©√©e")
                    print("üîß Le scraper s'ex√©cutera en arri√®re-plan dans un screen")
                    print()
                    
                    if self.confirm_launch():
                        await self.launch_trendtrack_scraper()
                
                elif choice == 3:  # Nettoyer les locks
                    self.clean_locks()
                
                elif choice == 4:  # Fichiers r√©cents
                    self.show_recent_files()
                
                elif choice == 5:  # Logs
                    self.show_logs()
                
                elif choice == 6:  # Monitoring en temps r√©el
                    self.show_realtime_monitoring()
                
                elif choice == 7:  # Statistiques par statut
                    self.show_shop_status_stats()
                
                elif choice == 8:  # Configuration
                    self.show_configuration()
                
                elif choice == 9:  # Aide
                    self.show_help()
                
                elif choice == 10:  # Quitter
                    print("\nüëã Au revoir!")
                    break
                
            except KeyboardInterrupt:
                print("\nüëã Au revoir!")
                break
            except Exception as e:
                print(f"‚ùå Erreur: {e}")
                input("\nAppuyez sur Entr√©e pour continuer...")

def main():
    """Fonction principale"""
    setup_logging()
    
    try:
        menu = WorkersMenu()
        asyncio.run(menu.run_menu())
    except KeyboardInterrupt:
        print("\n\nüëã Arr√™t demand√© par l'utilisateur")
    except Exception as e:
        print(f"\n‚ùå Erreur inattendue: {e}")
    finally:
        print("\nüëã Au revoir!")

if __name__ == "__main__":
    main()
